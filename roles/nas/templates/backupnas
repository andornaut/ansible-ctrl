#!/bin/bash

set -euo nounset

SCRIPT_NAME=$(basename "${0}")
RETENTION_NUMBER="{{ nas_backup_directories_retention }}"
MOUNT_ONLY=false
UNMOUNT_ONLY=false
NO_MOUNT=false
DEVICE_PATH=/dev/mapper/nasbackup
SOURCE_DIR="{{ nas_backup_directory }}"
POSITIONAL_COUNT=0

# Output helper functions
error() { echo -e " \033[1;31m✗\033[0m  $@" >&2; }
header() { echo -e "\n\033[1m$@\033[0m\n"; }
info() { echo -e " \033[1;34m•\033[0m  $@"; }
ok() { echo -e " \033[1;32m✔\033[0m  ${@-OK}"; }
warn() { echo -e " \033[1;33m!\033[0m  $@" >&2; }

# Parse flags and positional arguments
while [[ $# -gt 0 ]]; do
    case "${1}" in
        --mount-only)
            MOUNT_ONLY=true
            shift
            ;;
        --unmount)
            UNMOUNT_ONLY=true
            shift
            ;;
        --no-mount)
            NO_MOUNT=true
            shift
            ;;
        --help|-h)
            cat >&2 <<EOF
Usage: ${SCRIPT_NAME} [OPTIONS] [DEVICE_PATH] [SOURCE_DIR]

Options:
  --mount-only  Only mount the device without starting backup
  --unmount     Unmount and close the encrypted device
  --no-mount    Do not mount or unmount (assumes already mounted)

Arguments:
  DEVICE_PATH   Path to encrypted device (default: /dev/mapper/nasbackup)
  SOURCE_DIR    Source directory to backup (default: {{ nas_backup_directory }})

Examples:
  ${SCRIPT_NAME}                                 # Full backup with defaults
  ${SCRIPT_NAME} --mount-only                    # Just mount with defaults
  ${SCRIPT_NAME} --unmount /dev/mapper/nasbackup # Unmount specific device
  ${SCRIPT_NAME} /dev/mapper/nasbackup {{ nas_backup_directory }} # Custom device and source

Setup:
  Add entries to /etc/crypttab and /etc/fstab for each encrypted device.

  /etc/crypttab:
    nasbackup /dev/disk/by-id/DEVICE_ID /path/to/keyfile luks,noauto

  /etc/fstab:
    /dev/mapper/nasbackup /media/nasbackup btrfs defaults,noauto,x-systemd.after=blockdev@dev-mapper-nasbackup.target,x-systemd.requires=dev-mapper-nasbackup.device,x-systemd.requires-mounts-for=/dev/mapper/nasbackup,x-systemd.device-timeout=20s 0 0
EOF
            exit 0
            ;;
        -*)
            error "Unknown option: ${1}\nUse --help for usage information"
            ;;
        *)
            # Positional arguments in order
            if [[ ${POSITIONAL_COUNT} -eq 0 ]]; then
                DEVICE_PATH="${1}"
                POSITIONAL_COUNT=$((POSITIONAL_COUNT + 1))
            elif [[ ${POSITIONAL_COUNT} -eq 1 ]]; then
                SOURCE_DIR="${1}"
                POSITIONAL_COUNT=$((POSITIONAL_COUNT + 1))
            else
                error "Too many arguments\nUse --help for usage information"
            fi
            shift
            ;;
    esac
done

[[ ${EUID} -eq 0 ]] || { error 'Must be run as root'; }
[[ "${MOUNT_ONLY}" == false && "${UNMOUNT_ONLY}" == false && ! -d "${SOURCE_DIR}" ]] && { error "\$SOURCE_DIR does not exist: ${SOURCE_DIR}"; }

DEVICE_NAME=$(basename "${DEVICE_PATH}")

openLuks() {
    if [[ ! -e "${DEVICE_PATH}" ]]; then
        info "Opening encrypted device: ${DEVICE_NAME}"
        cryptdisks_start "${DEVICE_NAME}"
        [[ ! -e "${DEVICE_PATH}" ]] && { error "Failed to open encrypted device ${DEVICE_NAME}"; }
        # Wait for udev to finish processing the new device
        udevadm settle
    fi
}

mountDevice() {
    header "Mounting device..."

    openLuks

    # Check if device is already mounted
    MOUNT_DIR="$(findmnt -rno TARGET "${DEVICE_PATH}" | head -n1)"

    # If not mounted and NO_MOUNT is false, try to mount it
    if [[ -z "${MOUNT_DIR}" && "${NO_MOUNT}" == false ]]; then
        mount "${DEVICE_PATH}" || error "Failed to mount ${DEVICE_PATH}"
        MOUNT_DIR="$(findmnt -rno TARGET "${DEVICE_PATH}" | head -n1)"
        [[ -z "${MOUNT_DIR}" ]] && { error "Mount succeeded but device not found at expected mount point"; }
    fi

    [[ -z "${MOUNT_DIR}" ]] && { error "Device ${DEVICE_PATH} is not mounted"; }

    ok "Device mounted: ${MOUNT_DIR}"

    header "Manual commands:"
    info "Mount:   mount \"${DEVICE_PATH}\""
    info "Unmount: umount \"${MOUNT_DIR}\" && cryptdisks_stop \"${DEVICE_NAME}\""
}

closeLuks() {
    header "Unmounting and closing device..."

    if [[ ! -e "${DEVICE_PATH}" ]]; then
        error "Device ${DEVICE_PATH} does not exist"
    fi
    local retry_secs=10
    local mount_dirs
    mount_dirs="$(findmnt -rno TARGET "${DEVICE_PATH}")" || true
    if [[ -n "${mount_dirs}" ]]; then
        info "Unmounting: ${mount_dirs}"
        for dir in ${mount_dirs}; do
            umount "${dir}" || { sleep ${retry_secs}; umount "${dir}"; }
        done
    fi
    cryptdisks_stop "${DEVICE_NAME}"
    ok "Device unmounted and closed"
}

deleteOldBackups() {
    header "Deleting old backups..."
    local oldBackups=$(ls -1p "${MOUNT_DIR}" | grep -P '^rsnapshot\.\d{4}-\d{2}-\d{2}/$' | head -n-${RETENTION_NUMBER})
    if [[ -n "${oldBackups}" ]]; then
        echo "${oldBackups}" | xargs -I {} rm -rf -- "${MOUNT_DIR}/{}"
        ok "Old backups deleted"
    else
        warn "No old backups to delete"
    fi
}

performBackup() {
    header "Starting backup..."
    local startTime=$(date +%s)
    if rsync --archive --delete --human-readable --info=progress2 --stats "${SOURCE_DIR}" "${DEST_DIR}"; then
        local endTime=$(date +%s)
        local duration=$((endTime - startTime))
        ok "Backup complete in ${duration} seconds"
    else
        error "rsync failed with exit code $?"
    fi
}

[[ "${UNMOUNT_ONLY}" == true ]] && { closeLuks; exit 0; }

mountDevice

[[ "${MOUNT_ONLY}" == true ]] && exit 0

# Safety check: ensure source is not within mount directory
if [[ "${SOURCE_DIR}" == "${MOUNT_DIR}"* ]]; then
    error "SOURCE_DIR cannot be inside MOUNT_DIR\n  Source: ${SOURCE_DIR}\n  Mount:  ${MOUNT_DIR}"
fi

# Backup
DEST_DIR="${MOUNT_DIR}/rsnapshot.$(date -d @$(stat --format=%Y "${SOURCE_DIR}") +%Y-%m-%d)"
header "Backup configuration:"
info "Source:      ${SOURCE_DIR}"
info "Destination: ${DEST_DIR}"
info "Retention:   ${RETENTION_NUMBER} backups"

mkdir -p "${DEST_DIR}"

deleteOldBackups
performBackup

tree -L 2 "${MOUNT_DIR}"
echo ""
if [[ "${NO_MOUNT}" == false ]]; then
    closeLuks
fi
