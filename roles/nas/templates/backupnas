#!/bin/bash

set -euo nounset

SCRIPT_NAME=$(basename "${0}")
RETENTION_NUMBER="{{ nas_backup_directories_retention }}"
MOUNT_ONLY=false
UNMOUNT_ONLY=false
NO_MOUNT=false
DEVICE_PATH=/dev/mapper/nasbackup
SOURCE_DIR="{{ nas_backup_directory }}"
POSITIONAL_COUNT=0

# Output helper functions
error() { echo -e " \033[1;31m✗\033[0m  $@" >&2; }
header() { echo -e "\n\033[1m$@\033[0m\n"; }
info() { echo -e " \033[1;34m•\033[0m  $@"; }
ok() { echo -e " \033[1;32m✔\033[0m  ${@-OK}"; }
warn() { echo -e " \033[1;33m!\033[0m  $@" >&2; }

# Parse flags and positional arguments
while [[ $# -gt 0 ]]; do
    case "${1}" in
        --mount-only)
            MOUNT_ONLY=true
            shift
            ;;
        --unmount)
            UNMOUNT_ONLY=true
            shift
            ;;
        --no-mount)
            NO_MOUNT=true
            shift
            ;;
        --help|-h)
            cat >&2 <<EOF
Usage: ${SCRIPT_NAME} [OPTIONS] [DEVICE_PATH] [SOURCE_DIR]

Options:
  --mount-only  Only mount the device without starting backup
  --unmount     Unmount and close the encrypted device
  --no-mount    Do not mount or unmount (assumes already mounted)

Arguments:
  DEVICE_PATH   Path to encrypted device (default: /dev/mapper/nasbackup)
  SOURCE_DIR    Source directory to backup (default: {{ nas_backup_directory }})

Examples:
  ${SCRIPT_NAME}                                 # Full backup with defaults
  ${SCRIPT_NAME} --mount-only                    # Just mount with defaults
  ${SCRIPT_NAME} --unmount /dev/mapper/nasbackup # Unmount specific device
  ${SCRIPT_NAME} /dev/mapper/nasbackup {{ nas_backup_directory }} # Custom device and source
EOF
            exit 0
            ;;
        -*)
            error "Unknown option: ${1}\nUse --help for usage information"
            exit 1
            ;;
        *)
            # Positional arguments in order
            if [[ ${POSITIONAL_COUNT} -eq 0 ]]; then
                DEVICE_PATH="${1}"
                POSITIONAL_COUNT=$((POSITIONAL_COUNT + 1))
            elif [[ ${POSITIONAL_COUNT} -eq 1 ]]; then
                SOURCE_DIR="${1}"
                POSITIONAL_COUNT=$((POSITIONAL_COUNT + 1))
            else
                error "Too many arguments\nUse --help for usage information"
                exit 1
            fi
            shift
            ;;
    esac
done

[[ ${EUID} -eq 0 ]] || { error 'Must be run as root'; exit 1; }
[[ "${MOUNT_ONLY}" == false && "${UNMOUNT_ONLY}" == false && ! -d "${SOURCE_DIR}" ]] && { error "\$SOURCE_DIR does not exist: ${SOURCE_DIR}"; exit 1; }

DEVICE_NAME=$(basename "${DEVICE_PATH}")

closeLuks() {
    if [[ ! -e "${DEVICE_PATH}" ]]; then
        error "Device ${DEVICE_PATH} does not exist"
        exit 1
    fi

    local retry_secs=10
    local mount_dirs="$(findmnt -rno TARGET "${DEVICE_PATH}")" || true
    if [[ -n "${mount_dirs}" ]]; then
        info "Unmounting: ${mount_dirs}"
        for dir in ${mount_dirs}; do
            umount "${dir}" || { sleep ${retry_secs}; umount "${dir}"; }
        done
    fi
    cryptdisks_stop "${DEVICE_NAME}"
}

[[ "${UNMOUNT_ONLY}" == true ]] && { closeLuks; ok "Device unmounted and closed"; exit 0; }

systemdUnit=$(systemd-escape --path --suffix=mount "${DEVICE_PATH}")

# Mount via systemctl (handles LUKS unlocking via crypttab)
if [[ "${NO_MOUNT}" == false ]]; then
    systemctl start "${systemdUnit}" || true
fi
MOUNT_DIR="$(findmnt -rno TARGET "${DEVICE_PATH}" | head -1)"

[[ -z "${MOUNT_DIR}" ]] && { error "Could not derive mount directory"; exit 1; }

ok "Device mounted: ${MOUNT_DIR}"

header "Manual commands:"
info "Mount:   systemctl start \"${systemdUnit}\""
info "Unmount: systemctl stop \"${systemdUnit}\" && cryptdisks_stop \"${DEVICE_NAME}\""

[[ "${MOUNT_ONLY}" == true ]] && exit 0

# Safety check: ensure source is not within mount directory
if [[ "${SOURCE_DIR}" == "${MOUNT_DIR}"* ]]; then
    error "SOURCE_DIR cannot be inside MOUNT_DIR\n  Source: ${SOURCE_DIR}\n  Mount:  ${MOUNT_DIR}"
    exit 1
fi

# Backup
DEST_DIR="${MOUNT_DIR}/rsnapshot.$(date -d @$(stat --format=%Y "${SOURCE_DIR}") +%Y-%m-%d)"
header "Backup configuration:"
info "Source:      ${SOURCE_DIR}"
info "Destination: ${DEST_DIR}"
info "Retention:   ${RETENTION_NUMBER} backups"

mkdir -p "${DEST_DIR}"

header "Deleting old backups..."
oldBackups=$(ls -1p "${MOUNT_DIR}" | grep -P '^rsnapshot\.\d{4}-\d{2}-\d{2}/$' | head -n-${RETENTION_NUMBER})
if [[ -n "${oldBackups}" ]]; then
    echo "${oldBackups}" | xargs -I {} rm -rf -- "${MOUNT_DIR}/{}"
else
    warn "No old backups to delete"
fi

header "Starting backup..."
startTime=$(date +%s)
if rsync --archive --delete --human-readable --info=progress2 --stats "${SOURCE_DIR}" "${DEST_DIR}"; then
    endTime=$(date +%s)
    duration=$((endTime - startTime))
    ok "Backup complete in ${duration} seconds"
else
    error "rsync failed with exit code $?"
    exit 1
fi

tree -L 2 "${MOUNT_DIR}"
echo ""
if [[ "${NO_MOUNT}" == false ]]; then
    closeLuks
fi
